Goals:
1. Ensure no logging opportunities are "missed" (where the logging tasks skips a control task execution)
2. Retain ability to change logs/second (per variable)
3. Make it possible to change what variables are logged without changing the C code


Idea 1: "synced" logging. Control task runs X times per second. Logging function
runs synced with a control task and logs variables associated with that task.
The user calls logVariables(task_id) at the end of each task loop, this will do a log cycle
for all variables in that specific task.

A prescalar is used to determine how often the logging function actually logs each of the variables.

Requires each logged variable to have an associated task, which would require extra overhead for each logged variable.



Idea 2: "synced" user-dictated logging. Logged variables are logged at the end
of a control task sequence. This would require the user to pass a variable into a function
to log it.

Does not satisfy Goal #3

Bonus: Allows the user to log non-global variables and does not require a mapfile.



Idea 3: configTICK_RATE_HZ log task. Logging task runs at max frequency (configTICK_RATE_HZ).
Each variable is logged at a prescalar frequency from the configTICK_RATE_HZ.

Does not satisfy Goal #1




Idea 4:

Global clock half cycles - global mutex on/off where on runs control task and off runs log tasks

Final idea:
call logCallback(&LOG_current_c, T_FLOAT, "LOG_current_c"); at the end of the control task
address or by name?

by name.

no need for mapfile

Todo: profile time to log (buffered and streaming)
and for subrate logging (non-hit log callbacks time)


Problems:
Multiple sockets at once straight up doesn't work. We get stuck inside xEventGroupWaitBits
which is in prvRecvWait which is called by FreeRTOS_recv inside the prvServerConnectionInstance task

This is only the case for the second socket made (when the first one still exists)
No idea why.

Okay this ALSO happens if a socket closes due to timeout?

It happens if the prvServerConnectionInstance has an instance running
oh my god, is it because prvServerConnectionInstance is static?
No, that wasn't why

Okay but I've confirmed, it breaks when more than one prvServerConnectionInstance
task is running.

This even happens if the prvServerConnectionInstance is just sitting there doing nothing

THE MEMORY WAS STATIC
I hate everything


Notes for meeting:
- Streamed logging window size isn't working (nothing is getting cleared)
- There's a (probably memory) bug that I can't always reproduce. Sometimes when a socket is created the system crashes
- There appears to also be a memory leak.
- The way I get rid of sockets after 5 seconds isn't very good (especially with ascii cmd sockets)

new logging file(s):
- lists variables that can be logged (and types, like a mapfile)
- communicates between C code and python code which variables can be logged and where they are
- fills buffer of data with logging data and passes it to logging function (in C)
- python knows how to parse the data